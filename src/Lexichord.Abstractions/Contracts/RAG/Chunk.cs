// =============================================================================
// File: Chunk.cs
// Project: Lexichord.Abstractions
// Description: Record representing a document chunk with its embedding vector.
// =============================================================================
// LOGIC: Chunks are the atomic units for vector similarity search.
//   - Each chunk contains a portion of the parent document's text.
//   - The Embedding property holds the vector representation (1536 dimensions for OpenAI).
//   - StartOffset and EndOffset enable navigation back to the source location.
//   - v0.5.3c: Added Heading and HeadingLevel for breadcrumb navigation.
// =============================================================================

namespace Lexichord.Abstractions.Contracts.RAG;

/// <summary>
/// Represents a chunk of a document with its embedding vector for similarity search.
/// </summary>
/// <remarks>
/// <para>
/// Chunks are the fundamental units of the RAG system's vector search. Each chunk
/// contains a portion of the parent document's text along with its embedding vector,
/// enabling semantic similarity matching via <see cref="IChunkRepository.SearchSimilarAsync"/>.
/// </para>
/// <para>
/// The chunking strategy (size, overlap) affects both search quality and storage
/// requirements. Typical configurations use 512-1024 tokens per chunk with 10-20%
/// overlap to maintain context across boundaries.
/// </para>
/// <para>
/// This record maps to the <c>chunks</c> table created by Migration_003_VectorSchema,
/// which uses pgvector's <c>vector(1536)</c> type for efficient HNSW indexing.
/// </para>
/// </remarks>
/// <param name="Id">
/// The unique identifier for this chunk.
/// Generated by the database (UUID/GUID) when the chunk is stored.
/// </param>
/// <param name="DocumentId">
/// The identifier of the parent document.
/// Foreign key to <see cref="Document.Id"/> with cascade delete.
/// </param>
/// <param name="Content">
/// The text content of this chunk.
/// This is the actual textual content that was embedded and will be
/// returned in search results.
/// </param>
/// <param name="Embedding">
/// The vector representation of the chunk content.
/// For OpenAI text-embedding-3-small, this is a 1536-dimensional float array.
/// Null if embedding generation has not yet occurred.
/// </param>
/// <param name="ChunkIndex">
/// The zero-based position of this chunk within its parent document.
/// Enables ordering chunks for context reconstruction.
/// </param>
/// <param name="StartOffset">
/// The character offset where this chunk begins in the source document.
/// Used for navigation: jumping to the source location when a chunk is selected.
/// </param>
/// <param name="EndOffset">
/// The character offset where this chunk ends in the source document.
/// Together with <paramref name="StartOffset"/>, defines the exact source region.
/// </param>
/// <param name="Heading">
/// The section heading this chunk belongs to, if applicable.
/// Null for chunks without heading context (e.g., preamble content or
/// documents without headers). Populated during Markdown header chunking.
/// </param>
/// <param name="HeadingLevel">
/// The heading level (1-6) if this chunk is under a Markdown header.
/// Zero if no heading applies. Level 1 = H1, Level 2 = H2, etc.
/// </param>
public record Chunk(
    Guid Id,
    Guid DocumentId,
    string Content,
    float[]? Embedding,
    int ChunkIndex,
    int StartOffset,
    int EndOffset,
    string? Heading = null,
    int HeadingLevel = 0)
{
    /// <summary>
    /// Creates a new chunk without an embedding (pre-embedding state).
    /// </summary>
    /// <param name="documentId">The parent document's identifier.</param>
    /// <param name="content">The text content of this chunk.</param>
    /// <param name="chunkIndex">The position within the document.</param>
    /// <param name="startOffset">Character offset where chunk begins.</param>
    /// <param name="endOffset">Character offset where chunk ends.</param>
    /// <param name="heading">Optional section heading this chunk belongs to.</param>
    /// <param name="headingLevel">Heading level (1-6), or 0 if no heading.</param>
    /// <returns>A new <see cref="Chunk"/> ready for embedding generation.</returns>
    /// <remarks>
    /// Use this factory method during the chunking phase before embeddings are generated.
    /// The <see cref="Id"/> is set to <see cref="Guid.Empty"/> (database assigns) and
    /// <see cref="Embedding"/> is null (will be populated by embedding service).
    /// </remarks>
    public static Chunk CreateWithoutEmbedding(
        Guid documentId,
        string content,
        int chunkIndex,
        int startOffset,
        int endOffset,
        string? heading = null,
        int headingLevel = 0)
    {
        return new Chunk(
            Id: Guid.Empty,
            DocumentId: documentId,
            Content: content,
            Embedding: null,
            ChunkIndex: chunkIndex,
            StartOffset: startOffset,
            EndOffset: endOffset,
            Heading: heading,
            HeadingLevel: headingLevel);
    }

    /// <summary>
    /// Gets the length of the chunk content in characters.
    /// </summary>
    /// <value>The character count of <see cref="Content"/>.</value>
    public int ContentLength => Content.Length;

    /// <summary>
    /// Gets the dimensionality of the embedding vector.
    /// </summary>
    /// <value>
    /// The number of dimensions in <see cref="Embedding"/>, or 0 if not yet embedded.
    /// </value>
    public int EmbeddingDimensions => Embedding?.Length ?? 0;

    /// <summary>
    /// Gets whether this chunk has heading context.
    /// </summary>
    /// <value>
    /// <c>true</c> if <see cref="Heading"/> is not null or empty; otherwise, <c>false</c>.
    /// </value>
    public bool HasHeading => !string.IsNullOrEmpty(Heading);
}
