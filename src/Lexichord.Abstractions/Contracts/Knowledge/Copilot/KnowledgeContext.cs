// =============================================================================
// File: KnowledgeContext.cs
// Project: Lexichord.Abstractions
// Description: Knowledge context record for Co-pilot prompt injection.
// =============================================================================
// LOGIC: Aggregates entities, relationships, axioms, and claims retrieved
//   from the Knowledge Graph into a single context object with formatted
//   text suitable for LLM prompt injection. Tracks token count and
//   truncation status for budget management.
//
// v0.6.6e: Graph Context Provider (CKVS Phase 3b)
// Dependencies: KnowledgeEntity, KnowledgeRelationship (v0.4.5e),
//               Axiom (v0.4.6e), Claim (v0.5.6e)
// =============================================================================

using Lexichord.Abstractions.Contracts.Knowledge.Claims;

namespace Lexichord.Abstractions.Contracts.Knowledge.Copilot;

/// <summary>
/// Knowledge context for LLM prompts.
/// </summary>
/// <remarks>
/// <para>
/// The <see cref="KnowledgeContext"/> record encapsulates all knowledge graph
/// data retrieved for a Co-pilot prompt, including entities, relationships,
/// axioms, and claims. It provides both structured data (for programmatic
/// access) and a pre-formatted string (for direct prompt injection).
/// </para>
/// <para>
/// <b>Token Budget:</b> The <see cref="TokenCount"/> field tracks the
/// estimated token usage of <see cref="FormattedContext"/>. When the context
/// exceeds the budget, <see cref="WasTruncated"/> is set to <c>true</c>
/// and lower-relevance entities are omitted.
/// </para>
/// <para>
/// <b>License Gating:</b>
/// <list type="bullet">
///   <item><c>WriterPro</c>: Entity context only.</item>
///   <item><c>Teams</c>: Full context (entities + axioms).</item>
///   <item><c>Enterprise</c>: Full + custom formats.</item>
/// </list>
/// </para>
/// <para>
/// <b>Introduced in:</b> v0.6.6e as part of the Graph Context Provider.
/// </para>
/// </remarks>
/// <example>
/// <code>
/// var context = await provider.GetContextAsync("GET /api/users", options, ct);
/// if (context.Entities.Count > 0)
/// {
///     prompt.Append(context.FormattedContext);
///     logger.LogDebug("Injected {TokenCount} tokens of knowledge context", context.TokenCount);
/// }
/// </code>
/// </example>
public record KnowledgeContext
{
    /// <summary>
    /// Relevant entities from the knowledge graph.
    /// </summary>
    /// <value>
    /// A read-only list of entities ranked by relevance to the original query.
    /// Never null; empty list if no entities were found.
    /// </value>
    /// <remarks>
    /// LOGIC: Entities are ordered by descending relevance score after
    /// ranking and budget-constrained selection.
    /// </remarks>
    public required IReadOnlyList<KnowledgeEntity> Entities { get; init; }

    /// <summary>
    /// Relevant relationships between the selected entities.
    /// </summary>
    /// <value>
    /// Relationships connecting the entities in <see cref="Entities"/>,
    /// or null if relationships were not requested.
    /// </value>
    /// <remarks>
    /// LOGIC: Only relationships where both endpoints are in the selected
    /// entity set are included, preventing dangling references.
    /// </remarks>
    public IReadOnlyList<KnowledgeRelationship>? Relationships { get; init; }

    /// <summary>
    /// Applicable axioms (domain rules) for the selected entity types.
    /// </summary>
    /// <value>
    /// Axioms targeting the entity types present in the context,
    /// or null if axioms were not requested.
    /// </value>
    /// <remarks>
    /// LOGIC: Requires Teams+ license tier. Axioms provide domain
    /// constraints that help the LLM generate accurate content.
    /// </remarks>
    public IReadOnlyList<Axiom>? Axioms { get; init; }

    /// <summary>
    /// Related claims from source documents.
    /// </summary>
    /// <value>
    /// Claims involving the selected entities, or null if claims were
    /// not requested.
    /// </value>
    /// <remarks>
    /// LOGIC: Limited to top 3 claims per entity (max 5 entities) for
    /// performance. Provides grounding evidence for LLM generation.
    /// </remarks>
    public IReadOnlyList<Claim>? Claims { get; init; }

    /// <summary>
    /// Formatted context string for direct prompt injection.
    /// </summary>
    /// <value>
    /// A pre-formatted string in the requested format (Markdown, YAML,
    /// JSON, or plain text). Empty string if no entities were found.
    /// </value>
    /// <remarks>
    /// LOGIC: Generated by <see cref="IKnowledgeContextFormatter.FormatContext"/>
    /// using the entities, relationships, and axioms.
    /// </remarks>
    public string FormattedContext { get; init; } = "";

    /// <summary>
    /// Token count of the formatted context.
    /// </summary>
    /// <value>
    /// Estimated token count using GPT-style approximation (~4 chars/token).
    /// </value>
    public int TokenCount { get; init; }

    /// <summary>
    /// Query used to retrieve this context.
    /// </summary>
    /// <value>
    /// The original query string, or null if context was retrieved by
    /// entity IDs.
    /// </value>
    public string? OriginalQuery { get; init; }

    /// <summary>
    /// Whether the context was truncated due to token budget constraints.
    /// </summary>
    /// <value>
    /// <c>true</c> if some relevant entities were omitted to stay within
    /// the token budget; otherwise <c>false</c>.
    /// </value>
    /// <remarks>
    /// LOGIC: Set to true when the number of ranked entities exceeds the
    /// number of selected entities after budget-constrained selection.
    /// </remarks>
    public bool WasTruncated { get; init; }

    /// <summary>
    /// Creates an empty knowledge context with no entities or formatted output.
    /// </summary>
    /// <value>A singleton empty context instance.</value>
    /// <remarks>
    /// LOGIC: Used as a safe default when no entities match the query
    /// or the knowledge graph is unavailable.
    /// </remarks>
    public static KnowledgeContext Empty => new()
    {
        Entities = [],
        FormattedContext = "",
        TokenCount = 0
    };
}
