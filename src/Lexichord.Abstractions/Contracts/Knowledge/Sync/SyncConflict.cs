// =============================================================================
// File: SyncConflict.cs
// Project: Lexichord.Abstractions
// Description: Record representing a conflict detected during synchronization.
// =============================================================================
// LOGIC: When document and graph state diverge, conflicts are created to
//   track what differs and enable resolution. Each conflict captures the
//   target (entity/property), both values, type, and severity.
//
// v0.7.6e: Sync Service Core (CKVS Phase 4c)
// Dependencies: ConflictType, ConflictSeverity (v0.7.6e)
// =============================================================================

namespace Lexichord.Abstractions.Contracts.Knowledge.Sync;

/// <summary>
/// A conflict detected during document-graph synchronization.
/// </summary>
/// <remarks>
/// <para>
/// Captures details about a sync conflict:
/// </para>
/// <list type="bullet">
///   <item><b>Target:</b> What entity or property is in conflict.</item>
///   <item><b>Values:</b> Document value vs. graph value.</item>
///   <item><b>Type:</b> Nature of the conflict (see <see cref="ConflictType"/>).</item>
///   <item><b>Severity:</b> How urgently it needs attention (see <see cref="ConflictSeverity"/>).</item>
/// </list>
/// <para>
/// <b>Usage:</b>
/// <code>
/// foreach (var conflict in result.Conflicts)
/// {
///     Console.WriteLine($"Conflict on {conflict.ConflictTarget}:");
///     Console.WriteLine($"  Document: {conflict.DocumentValue}");
///     Console.WriteLine($"  Graph: {conflict.GraphValue}");
///     Console.WriteLine($"  Type: {conflict.Type}, Severity: {conflict.Severity}");
/// }
/// </code>
/// </para>
/// <para>
/// <b>Introduced in:</b> v0.7.6e as part of the Sync Service Core.
/// </para>
/// </remarks>
public record SyncConflict
{
    /// <summary>
    /// The entity or field that is in conflict.
    /// </summary>
    /// <value>
    /// A string identifying the conflict target. Format varies by context:
    /// "Entity:Name" for entity conflicts, "Entity.Property" for property conflicts.
    /// </value>
    /// <remarks>
    /// LOGIC: Used to locate and display the conflict in the UI.
    /// Should be human-readable but also machine-parseable for navigation.
    /// </remarks>
    public required string ConflictTarget { get; init; }

    /// <summary>
    /// The value from the document.
    /// </summary>
    /// <value>
    /// The current value as extracted from the document.
    /// Type depends on the property (string, number, entity reference, etc.).
    /// </value>
    /// <remarks>
    /// LOGIC: Boxed as object to support any value type. The UI should
    /// format this appropriately based on the conflict target type.
    /// </remarks>
    public required object DocumentValue { get; init; }

    /// <summary>
    /// The value from the knowledge graph.
    /// </summary>
    /// <value>
    /// The current value stored in the graph.
    /// Type matches <see cref="DocumentValue"/> for comparison.
    /// </value>
    /// <remarks>
    /// LOGIC: The existing graph state that conflicts with the document.
    /// May be null for <see cref="ConflictType.MissingInGraph"/>.
    /// </remarks>
    public required object GraphValue { get; init; }

    /// <summary>
    /// Timestamp when the conflict was detected.
    /// </summary>
    /// <value>UTC timestamp of conflict detection.</value>
    /// <remarks>
    /// LOGIC: Recorded during sync operation. Used for conflict
    /// history and determining staleness.
    /// </remarks>
    public required DateTimeOffset DetectedAt { get; init; }

    /// <summary>
    /// Type of the conflict.
    /// </summary>
    /// <value>The nature of the divergence between document and graph.</value>
    /// <remarks>
    /// LOGIC: Determines appropriate resolution strategies. ValueMismatch
    /// can use merge; MissingInGraph suggests creation.
    /// </remarks>
    public required ConflictType Type { get; init; }

    /// <summary>
    /// Severity of the conflict.
    /// </summary>
    /// <value>
    /// How urgently the conflict needs attention. Defaults to Medium.
    /// </value>
    /// <remarks>
    /// LOGIC: Low severity conflicts may be auto-resolved. High severity
    /// requires explicit user intervention. Affects UI presentation.
    /// </remarks>
    public ConflictSeverity Severity { get; init; } = ConflictSeverity.Medium;

    /// <summary>
    /// Human-readable description of the conflict.
    /// </summary>
    /// <value>
    /// Detailed explanation of why this is a conflict and possible resolutions.
    /// Optional but recommended for user-facing display.
    /// </value>
    /// <remarks>
    /// LOGIC: Generated by the conflict detector to explain the situation
    /// to the user. May include suggestions for resolution.
    /// </remarks>
    public string? Description { get; init; }
}
