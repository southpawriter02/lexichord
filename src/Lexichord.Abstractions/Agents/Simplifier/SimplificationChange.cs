// -----------------------------------------------------------------------
// <copyright file="SimplificationChange.cs" company="Lexichord">
//     Copyright (c) Lexichord. All rights reserved.
//     Licensed under the MIT License.
// </copyright>
// -----------------------------------------------------------------------

namespace Lexichord.Abstractions.Agents.Simplifier;

/// <summary>
/// Represents a single change made during text simplification.
/// </summary>
/// <remarks>
/// <para>
/// <b>LOGIC:</b> Each <see cref="SimplificationChange"/> captures a discrete transformation
/// applied to the source text. Changes are extracted from the LLM response by the
/// <see cref="Lexichord.Modules.Agents.Simplifier.SimplificationResponseParser"/> and
/// included in the <see cref="SimplificationResult.Changes"/> collection.
/// </para>
/// <para>
/// <b>UI Integration:</b>
/// Changes are displayed in a diff-view panel where users can:
/// <list type="bullet">
///   <item><description>Review each change with original and simplified text</description></item>
///   <item><description>See the change type and explanation</description></item>
///   <item><description>Accept or reject individual changes (future v0.7.4c)</description></item>
/// </list>
/// </para>
/// <para>
/// <b>Introduced in:</b> v0.7.4b as part of the Simplifier Agent Simplification Pipeline.
/// </para>
/// </remarks>
/// <param name="OriginalText">
/// The original text segment before simplification. This is the exact text that was transformed.
/// </param>
/// <param name="SimplifiedText">
/// The simplified text segment after transformation. May differ significantly from
/// <paramref name="OriginalText"/> depending on the <see cref="SimplificationStrategy"/> used.
/// </param>
/// <param name="ChangeType">
/// The category of change that was applied. See <see cref="SimplificationChangeType"/> for
/// descriptions of each category.
/// </param>
/// <param name="Explanation">
/// A human-readable explanation of why this change improves readability.
/// Generated by the LLM to help users understand the transformation.
/// </param>
/// <param name="Location">
/// Optional location of the change within the original text.
/// May be <c>null</c> if location tracking is not available.
/// </param>
/// <param name="Confidence">
/// Confidence score for this change (0.0 to 1.0). Higher values indicate
/// stronger confidence that the change improves readability without altering meaning.
/// Defaults to 1.0 when not provided by the LLM.
/// </param>
/// <example>
/// <code>
/// // Creating a change record
/// var change = new SimplificationChange(
///     OriginalText: "The committee subsequently convened to deliberate upon the matter.",
///     SimplifiedText: "The committee then met to discuss the issue.",
///     ChangeType: SimplificationChangeType.WordSimplification,
///     Explanation: "Replaced 'subsequently' with 'then', 'convened' with 'met', 'deliberate upon' with 'discuss', and 'matter' with 'issue' for clarity.",
///     Location: new TextLocation(0, 66),
///     Confidence: 0.95);
///
/// // Displaying change in UI
/// Console.WriteLine($"Original: {change.OriginalText}");
/// Console.WriteLine($"Simplified: {change.SimplifiedText}");
/// Console.WriteLine($"Type: {change.ChangeType}");
/// Console.WriteLine($"Why: {change.Explanation}");
/// </code>
/// </example>
/// <seealso cref="SimplificationChangeType"/>
/// <seealso cref="SimplificationResult"/>
/// <seealso cref="TextLocation"/>
public record SimplificationChange(
    string OriginalText,
    string SimplifiedText,
    SimplificationChangeType ChangeType,
    string Explanation,
    TextLocation? Location = null,
    double Confidence = 1.0)
{
    /// <summary>
    /// Gets the length difference between the original and simplified text.
    /// </summary>
    /// <value>
    /// A positive value indicates the text was shortened (simplified).
    /// A negative value indicates the text was lengthened (e.g., adding explanations).
    /// </value>
    /// <remarks>
    /// <b>LOGIC:</b> Useful for metrics: simplification typically reduces text length.
    /// </remarks>
    public int LengthDifference => OriginalText.Length - SimplifiedText.Length;

    /// <summary>
    /// Gets a value indicating whether this change reduced the text length.
    /// </summary>
    /// <value>
    /// <c>true</c> if the simplified text is shorter than the original; otherwise, <c>false</c>.
    /// </value>
    /// <remarks>
    /// <b>LOGIC:</b> Most simplifications reduce length, but some (like adding transitions
    /// or explanations) may increase it.
    /// </remarks>
    public bool IsReduction => SimplifiedText.Length < OriginalText.Length;
}

/// <summary>
/// Represents a location within text, specified by character offset and length.
/// </summary>
/// <remarks>
/// <para>
/// <b>LOGIC:</b> Text locations enable highlighting of changes in the editor.
/// The <see cref="Start"/> offset is zero-based and <see cref="Length"/> is the
/// number of characters covered.
/// </para>
/// <para>
/// <b>Introduced in:</b> v0.7.4b as part of the Simplifier Agent Simplification Pipeline.
/// </para>
/// </remarks>
/// <param name="Start">Zero-based character offset from the beginning of the text.</param>
/// <param name="Length">Number of characters covered by this location.</param>
/// <example>
/// <code>
/// // A location covering characters 10-25 (inclusive of 10, exclusive of 25)
/// var location = new TextLocation(10, 15);
///
/// // Extracting text at location
/// var text = originalText.Substring(location.Start, location.Length);
///
/// // Check if location is within bounds
/// if (location.End &lt;= originalText.Length)
/// {
///     Console.WriteLine($"Valid location: {location}");
/// }
/// </code>
/// </example>
public record TextLocation(int Start, int Length)
{
    /// <summary>
    /// Gets the end offset (exclusive) of this location.
    /// </summary>
    /// <value>
    /// The character position immediately after the last character of this location.
    /// Calculated as <c>Start + Length</c>.
    /// </value>
    /// <remarks>
    /// <b>LOGIC:</b> Uses exclusive end convention, matching standard substring operations.
    /// </remarks>
    public int End => Start + Length;

    /// <summary>
    /// Determines whether this location contains the specified offset.
    /// </summary>
    /// <param name="offset">The character offset to check.</param>
    /// <returns>
    /// <c>true</c> if <paramref name="offset"/> is within this location; otherwise, <c>false</c>.
    /// </returns>
    /// <remarks>
    /// <b>LOGIC:</b> Uses inclusive start, exclusive end: <c>[Start, End)</c>.
    /// </remarks>
    public bool Contains(int offset) => offset >= Start && offset < End;

    /// <summary>
    /// Determines whether this location overlaps with another location.
    /// </summary>
    /// <param name="other">The other location to check for overlap.</param>
    /// <returns>
    /// <c>true</c> if the locations overlap; otherwise, <c>false</c>.
    /// </returns>
    /// <exception cref="ArgumentNullException">Thrown when <paramref name="other"/> is null.</exception>
    /// <remarks>
    /// <b>LOGIC:</b> Two locations overlap if one starts before the other ends
    /// and the other starts before the first ends.
    /// </remarks>
    public bool Overlaps(TextLocation other)
    {
        ArgumentNullException.ThrowIfNull(other);
        return Start < other.End && other.Start < End;
    }
}
