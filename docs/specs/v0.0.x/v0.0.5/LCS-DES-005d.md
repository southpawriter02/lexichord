# LCS-DES-005d: Repository Base

## 1. Metadata & Categorization

| Field                | Value                                | Description                                  |
| :------------------- | :----------------------------------- | :------------------------------------------- |
| **Feature ID**       | `INF-005d`                           | Infrastructure - Repository Base             |
| **Feature Name**     | Repository Base                      | IGenericRepository<T> with Dapper            |
| **Target Version**   | `v0.0.5d`                            | Fourth sub-part of v0.0.5                    |
| **Module Scope**     | `Lexichord.Infrastructure`           | Data access infrastructure                   |
| **Swimlane**         | `Infrastructure`                     | The Podium (Platform)                        |
| **License Tier**     | `Core`                               | Foundation (Required for all tiers)          |
| **Author**           | System Architect                     |                                              |
| **Status**           | **Draft**                            | Pending implementation                       |
| **Last Updated**     | 2026-01-26                           |                                              |

---

## 2. Executive Summary

### 2.1 The Requirement

Lexichord requires a **consistent data access pattern** that:

- Provides type-safe CRUD operations for all entities.
- Uses Dapper for high-performance SQL execution.
- Supports custom queries while maintaining consistency.
- Enables transaction management for multi-entity operations.

Without this foundation:

- Each module implements its own data access patterns.
- SQL queries are scattered and inconsistent.
- Testing requires database connections everywhere.
- Transactions are difficult to manage.

### 2.2 The Proposed Solution

We **SHALL** implement a generic repository pattern with:

1. **IGenericRepository<T, TId>** — Interface for standard CRUD operations.
2. **GenericRepository<T, TId>** — Dapper implementation with logging.
3. **IUserRepository** — Entity-specific repository with custom queries.
4. **ISystemSettingsRepository** — Key-value store repository.
5. **IUnitOfWork** — Transaction management pattern.

---

## 3. Implementation Tasks

### Task 1.1: Install NuGet Packages

**File:** `src/Lexichord.Infrastructure/Lexichord.Infrastructure.csproj`

```xml
<ItemGroup>
  <!-- Dapper ORM -->
  <PackageReference Include="Dapper" Version="2.1.35" />
  <PackageReference Include="Dapper.Contrib" Version="2.0.78" />
</ItemGroup>
```

**Rationale:**

- `Dapper` provides high-performance micro-ORM functionality.
- `Dapper.Contrib` adds simplified CRUD operations with attribute-based mapping.

---

### Task 1.2: Define Entity Base Class

**File:** `src/Lexichord.Abstractions/Entities/EntityBase.cs`

```csharp
using Dapper.Contrib.Extensions;

namespace Lexichord.Abstractions.Entities;

/// <summary>
/// Base class for entities with standard audit fields.
/// </summary>
/// <remarks>
/// LOGIC: All entities inherit these audit fields for tracking creation and modification times.
/// The [Computed] attribute tells Dapper.Contrib to not include these in INSERT/UPDATE as they
/// are managed by database defaults and triggers.
/// </remarks>
public abstract record EntityBase
{
    /// <summary>
    /// When the entity was created.
    /// </summary>
    /// <remarks>Set by database default, never modified by application code.</remarks>
    [Computed]
    public DateTimeOffset CreatedAt { get; init; }

    /// <summary>
    /// When the entity was last updated.
    /// </summary>
    /// <remarks>Updated by database trigger on modification.</remarks>
    [Computed]
    public DateTimeOffset UpdatedAt { get; init; }
}
```

---

### Task 1.3: Define Entity Classes

**File:** `src/Lexichord.Abstractions/Entities/User.cs`

```csharp
using Dapper.Contrib.Extensions;

namespace Lexichord.Abstractions.Entities;

/// <summary>
/// User entity representing a Lexichord user account.
/// </summary>
/// <remarks>
/// LOGIC: Users are identified by a UUID primary key for distributed systems compatibility.
/// The Email field is unique and serves as the login identifier.
/// PasswordHash is nullable to support OAuth-only authentication flows.
///
/// Mapping:
/// - Table: "Users"
/// - Primary Key: Id (UUID, auto-generated by database)
/// - Unique: Email
/// </remarks>
[Table("Users")]
public record User : EntityBase
{
    /// <summary>
    /// Unique identifier for the user.
    /// </summary>
    /// <remarks>
    /// UUID primary key generated by database using gen_random_uuid().
    /// [ExplicitKey] indicates this is the PK but NOT auto-increment.
    /// </remarks>
    [ExplicitKey]
    public Guid Id { get; init; }

    /// <summary>
    /// User's email address (unique, used for login).
    /// </summary>
    public required string Email { get; init; }

    /// <summary>
    /// Display name shown in the UI.
    /// </summary>
    public required string DisplayName { get; init; }

    /// <summary>
    /// Hashed password (null for OAuth-only users).
    /// </summary>
    /// <remarks>Uses bcrypt hashing with work factor 12.</remarks>
    public string? PasswordHash { get; init; }

    /// <summary>
    /// Whether the user account is active.
    /// </summary>
    /// <remarks>
    /// Inactive users cannot log in but their data is preserved.
    /// This enables soft-delete functionality.
    /// </remarks>
    public bool IsActive { get; init; } = true;
}
```

**File:** `src/Lexichord.Abstractions/Entities/SystemSetting.cs`

```csharp
using Dapper.Contrib.Extensions;

namespace Lexichord.Abstractions.Entities;

/// <summary>
/// System setting entity for key-value configuration storage.
/// </summary>
/// <remarks>
/// LOGIC: SystemSettings provides a flexible key-value store for application configuration
/// that may change at runtime without requiring a restart.
///
/// Common use cases:
/// - Feature flags
/// - Application version tracking
/// - Maintenance mode status
/// - Dynamic configuration
///
/// Mapping:
/// - Table: "SystemSettings"
/// - Primary Key: Key (string, explicit/natural key)
/// </remarks>
[Table("SystemSettings")]
public record SystemSetting
{
    /// <summary>
    /// Setting key (primary key).
    /// </summary>
    /// <remarks>
    /// [ExplicitKey] indicates this is the PK (natural key, not auto-generated).
    /// Keys should follow the pattern: "namespace:setting_name"
    /// Examples: "app:version", "system:maintenance_mode", "feature:dark_mode"
    /// </remarks>
    [ExplicitKey]
    public required string Key { get; init; }

    /// <summary>
    /// Setting value as text.
    /// </summary>
    /// <remarks>
    /// Values are stored as text and parsed by consuming code.
    /// For complex values, use JSON serialization.
    /// </remarks>
    public required string Value { get; init; }

    /// <summary>
    /// Human-readable description of the setting.
    /// </summary>
    /// <remarks>Helps administrators understand the purpose of each setting.</remarks>
    public string? Description { get; init; }

    /// <summary>
    /// When the setting was last updated.
    /// </summary>
    [Computed]
    public DateTimeOffset UpdatedAt { get; init; }
}
```

---

### Task 1.4: Define Generic Repository Interface

**File:** `src/Lexichord.Abstractions/Contracts/IGenericRepository.cs`

```csharp
using System.Linq.Expressions;

namespace Lexichord.Abstractions.Contracts;

/// <summary>
/// Generic repository interface for CRUD operations.
/// </summary>
/// <typeparam name="T">The entity type.</typeparam>
/// <typeparam name="TId">The primary key type.</typeparam>
/// <remarks>
/// LOGIC: This interface provides a consistent pattern for data access across all entities.
///
/// Design decisions:
/// - All methods are async for I/O-bound operations
/// - CancellationToken support for request cancellation
/// - Nullable return types where entity may not exist
/// - Transaction support via IUnitOfWork parameter
///
/// For custom queries beyond CRUD, use QueryAsync<TResult> or create
/// entity-specific repository interfaces that extend this one.
/// </remarks>
public interface IGenericRepository<T, TId> where T : class
{
    #region Read Operations

    /// <summary>
    /// Gets an entity by its primary key.
    /// </summary>
    /// <param name="id">The primary key value.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The entity, or null if not found.</returns>
    Task<T?> GetByIdAsync(TId id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all entities of this type.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>All entities.</returns>
    /// <remarks>
    /// WARNING: Use with caution on large tables. Consider using
    /// GetPagedAsync or QueryAsync with filtering for production code.
    /// </remarks>
    Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a paged result of entities.
    /// </summary>
    /// <param name="pageNumber">Page number (1-based).</param>
    /// <param name="pageSize">Number of items per page.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Paged result with total count.</returns>
    Task<PagedResult<T>> GetPagedAsync(
        int pageNumber,
        int pageSize,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an entity with the given ID exists.
    /// </summary>
    /// <param name="id">The primary key value.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the entity exists.</returns>
    Task<bool> ExistsAsync(TId id, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets the total count of entities.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Total number of entities.</returns>
    Task<long> CountAsync(CancellationToken cancellationToken = default);

    #endregion

    #region Write Operations

    /// <summary>
    /// Inserts a new entity.
    /// </summary>
    /// <param name="entity">The entity to insert.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The entity with any generated values populated (e.g., ID, timestamps).</returns>
    Task<T> InsertAsync(T entity, CancellationToken cancellationToken = default);

    /// <summary>
    /// Inserts multiple entities in a batch.
    /// </summary>
    /// <param name="entities">The entities to insert.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Number of entities inserted.</returns>
    Task<int> InsertManyAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default);

    /// <summary>
    /// Updates an existing entity.
    /// </summary>
    /// <param name="entity">The entity with updated values.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the entity was updated, false if not found.</returns>
    Task<bool> UpdateAsync(T entity, CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes an entity by its primary key.
    /// </summary>
    /// <param name="id">The primary key value.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the entity was deleted, false if not found.</returns>
    Task<bool> DeleteAsync(TId id, CancellationToken cancellationToken = default);

    #endregion

    #region Query Operations

    /// <summary>
    /// Executes a custom query and maps results to the specified type.
    /// </summary>
    /// <typeparam name="TResult">The result type.</typeparam>
    /// <param name="sql">The SQL query.</param>
    /// <param name="parameters">Query parameters (use anonymous object).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The query results.</returns>
    /// <example>
    /// <code>
    /// var users = await repo.QueryAsync&lt;User&gt;(
    ///     "SELECT * FROM \"Users\" WHERE \"IsActive\" = @IsActive",
    ///     new { IsActive = true });
    /// </code>
    /// </example>
    Task<IEnumerable<TResult>> QueryAsync<TResult>(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Executes a custom query and returns a single result.
    /// </summary>
    /// <typeparam name="TResult">The result type.</typeparam>
    /// <param name="sql">The SQL query.</param>
    /// <param name="parameters">Query parameters.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The single result, or null/default if not found.</returns>
    Task<TResult?> QuerySingleOrDefaultAsync<TResult>(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Executes a non-query command (INSERT, UPDATE, DELETE).
    /// </summary>
    /// <param name="sql">The SQL command.</param>
    /// <param name="parameters">Command parameters.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The number of affected rows.</returns>
    Task<int> ExecuteAsync(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Executes a scalar query (e.g., COUNT, SUM).
    /// </summary>
    /// <typeparam name="TResult">The scalar result type.</typeparam>
    /// <param name="sql">The SQL query.</param>
    /// <param name="parameters">Query parameters.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The scalar result.</returns>
    Task<TResult> ExecuteScalarAsync<TResult>(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default);

    #endregion
}

/// <summary>
/// Paged result containing items and pagination metadata.
/// </summary>
/// <typeparam name="T">The item type.</typeparam>
public record PagedResult<T>(
    IEnumerable<T> Items,
    int PageNumber,
    int PageSize,
    long TotalCount)
{
    /// <summary>
    /// Total number of pages.
    /// </summary>
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);

    /// <summary>
    /// Whether there is a previous page.
    /// </summary>
    public bool HasPreviousPage => PageNumber > 1;

    /// <summary>
    /// Whether there is a next page.
    /// </summary>
    public bool HasNextPage => PageNumber < TotalPages;
}
```

---

### Task 1.5: Implement Generic Repository

**File:** `src/Lexichord.Infrastructure/Data/GenericRepository.cs`

```csharp
using System.Data;
using System.Reflection;
using Dapper;
using Dapper.Contrib.Extensions;
using Microsoft.Extensions.Logging;
using Npgsql;
using Lexichord.Abstractions.Contracts;

namespace Lexichord.Infrastructure.Data;

/// <summary>
/// Generic repository implementation using Dapper for data access.
/// </summary>
/// <typeparam name="T">The entity type.</typeparam>
/// <typeparam name="TId">The primary key type.</typeparam>
/// <remarks>
/// LOGIC: This repository provides consistent CRUD operations for all entities.
///
/// Implementation details:
/// - Uses Dapper.Contrib for simple CRUD (Get, Insert, Update, Delete)
/// - Uses raw Dapper for custom queries (QueryAsync, ExecuteAsync)
/// - All operations use parameterized queries for SQL injection prevention
/// - Connections are acquired from the connection factory and returned to pool
/// - All operations are logged for observability
///
/// Thread safety:
/// - Repository instances are thread-safe
/// - Connections are not shared between operations
/// - Each async operation gets its own connection from the pool
/// </remarks>
public class GenericRepository<T, TId> : IGenericRepository<T, TId> where T : class
{
    private readonly IDbConnectionFactory _connectionFactory;
    private readonly ILogger<GenericRepository<T, TId>> _logger;
    private readonly string _tableName;
    private readonly string _idColumn;

    public GenericRepository(
        IDbConnectionFactory connectionFactory,
        ILogger<GenericRepository<T, TId>> logger)
    {
        _connectionFactory = connectionFactory;
        _logger = logger;
        _tableName = GetTableName();
        _idColumn = GetIdColumnName();
    }

    #region Read Operations

    /// <inheritdoc/>
    public async Task<T?> GetByIdAsync(TId id, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var result = await connection.GetAsync<T>(id);

        _logger.LogDebug(
            "GetById {Table} Id={Id}: {Result}",
            _tableName, id, result is not null ? "Found" : "NotFound");

        return result;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<T>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = $"SELECT * FROM \"{_tableName}\"";
        var command = new CommandDefinition(sql, cancellationToken: cancellationToken);
        var results = await connection.QueryAsync<T>(command);
        var count = results.Count();

        _logger.LogDebug("GetAll {Table}: {Count} records", _tableName, count);

        return results;
    }

    /// <inheritdoc/>
    public async Task<PagedResult<T>> GetPagedAsync(
        int pageNumber,
        int pageSize,
        CancellationToken cancellationToken = default)
    {
        if (pageNumber < 1) pageNumber = 1;
        if (pageSize < 1) pageSize = 10;
        if (pageSize > 1000) pageSize = 1000; // Safety limit

        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var offset = (pageNumber - 1) * pageSize;

        // Get total count
        var countSql = $"SELECT COUNT(*) FROM \"{_tableName}\"";
        var totalCount = await connection.ExecuteScalarAsync<long>(
            new CommandDefinition(countSql, cancellationToken: cancellationToken));

        // Get page items
        var sql = $@"
            SELECT * FROM ""{_tableName}""
            ORDER BY ""{_idColumn}""
            LIMIT @PageSize OFFSET @Offset";

        var items = await connection.QueryAsync<T>(
            new CommandDefinition(sql, new { PageSize = pageSize, Offset = offset }, cancellationToken: cancellationToken));

        _logger.LogDebug(
            "GetPaged {Table} Page={Page} Size={Size}: {Count} of {Total}",
            _tableName, pageNumber, pageSize, items.Count(), totalCount);

        return new PagedResult<T>(items, pageNumber, pageSize, totalCount);
    }

    /// <inheritdoc/>
    public async Task<bool> ExistsAsync(TId id, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = $"SELECT EXISTS(SELECT 1 FROM \"{_tableName}\" WHERE \"{_idColumn}\" = @Id)";
        var command = new CommandDefinition(sql, new { Id = id }, cancellationToken: cancellationToken);
        var exists = await connection.ExecuteScalarAsync<bool>(command);

        _logger.LogDebug("Exists {Table} Id={Id}: {Exists}", _tableName, id, exists);

        return exists;
    }

    /// <inheritdoc/>
    public async Task<long> CountAsync(CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = $"SELECT COUNT(*) FROM \"{_tableName}\"";
        var command = new CommandDefinition(sql, cancellationToken: cancellationToken);
        var count = await connection.ExecuteScalarAsync<long>(command);

        _logger.LogDebug("Count {Table}: {Count}", _tableName, count);

        return count;
    }

    #endregion

    #region Write Operations

    /// <inheritdoc/>
    public async Task<T> InsertAsync(T entity, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        // LOGIC: Dapper.Contrib.Insert returns the inserted ID for identity columns
        // For explicit keys (UUIDs), we need to handle differently
        var id = await connection.InsertAsync(entity);

        _logger.LogDebug("Insert {Table}: Success (Id={Id})", _tableName, id);

        // Re-fetch to get database-generated values (timestamps, etc.)
        return (await GetByIdAsync(GetIdValue(entity), cancellationToken))!;
    }

    /// <inheritdoc/>
    public async Task<int> InsertManyAsync(IEnumerable<T> entities, CancellationToken cancellationToken = default)
    {
        var entityList = entities.ToList();
        if (!entityList.Any()) return 0;

        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        // LOGIC: Dapper.Contrib.Insert handles batch inserts
        var inserted = await connection.InsertAsync(entityList);

        _logger.LogDebug("InsertMany {Table}: {Count} entities", _tableName, inserted);

        return (int)inserted;
    }

    /// <inheritdoc/>
    public async Task<bool> UpdateAsync(T entity, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var updated = await connection.UpdateAsync(entity);

        _logger.LogDebug(
            "Update {Table} Id={Id}: {Result}",
            _tableName, GetIdValue(entity), updated ? "Updated" : "NotFound");

        return updated;
    }

    /// <inheritdoc/>
    public async Task<bool> DeleteAsync(TId id, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        // LOGIC: Dapper.Contrib.Delete requires the entity, not just the ID
        // So we need to fetch first, or use raw SQL
        var sql = $"DELETE FROM \"{_tableName}\" WHERE \"{_idColumn}\" = @Id";
        var command = new CommandDefinition(sql, new { Id = id }, cancellationToken: cancellationToken);
        var affected = await connection.ExecuteAsync(command);

        var deleted = affected > 0;

        _logger.LogDebug(
            "Delete {Table} Id={Id}: {Result}",
            _tableName, id, deleted ? "Deleted" : "NotFound");

        return deleted;
    }

    #endregion

    #region Query Operations

    /// <inheritdoc/>
    public async Task<IEnumerable<TResult>> QueryAsync<TResult>(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var command = new CommandDefinition(sql, parameters, cancellationToken: cancellationToken);
        var results = await connection.QueryAsync<TResult>(command);
        var count = results.Count();

        _logger.LogDebug("Query executed: {Count} results", count);

        return results;
    }

    /// <inheritdoc/>
    public async Task<TResult?> QuerySingleOrDefaultAsync<TResult>(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var command = new CommandDefinition(sql, parameters, cancellationToken: cancellationToken);
        var result = await connection.QuerySingleOrDefaultAsync<TResult>(command);

        _logger.LogDebug("QuerySingle executed: {Found}", result is not null ? "Found" : "NotFound");

        return result;
    }

    /// <inheritdoc/>
    public async Task<int> ExecuteAsync(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var command = new CommandDefinition(sql, parameters, cancellationToken: cancellationToken);
        var affected = await connection.ExecuteAsync(command);

        _logger.LogDebug("Execute completed: {Affected} rows affected", affected);

        return affected;
    }

    /// <inheritdoc/>
    public async Task<TResult> ExecuteScalarAsync<TResult>(
        string sql,
        object? parameters = null,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var command = new CommandDefinition(sql, parameters, cancellationToken: cancellationToken);
        var result = await connection.ExecuteScalarAsync<TResult>(command);

        _logger.LogDebug("ExecuteScalar completed");

        return result;
    }

    #endregion

    #region Helper Methods

    /// <summary>
    /// Gets the table name from the entity type's [Table] attribute.
    /// </summary>
    private static string GetTableName()
    {
        var tableAttr = typeof(T).GetCustomAttribute<TableAttribute>();
        return tableAttr?.Name ?? typeof(T).Name + "s";
    }

    /// <summary>
    /// Gets the ID column name from the entity type's [Key] or [ExplicitKey] attribute.
    /// </summary>
    private static string GetIdColumnName()
    {
        var props = typeof(T).GetProperties();

        // Check for [Key] attribute
        var keyProp = props.FirstOrDefault(p =>
            p.GetCustomAttribute<KeyAttribute>() is not null);

        // Check for [ExplicitKey] attribute
        keyProp ??= props.FirstOrDefault(p =>
            p.GetCustomAttribute<ExplicitKeyAttribute>() is not null);

        // Default to "Id" if no attribute found
        return keyProp?.Name ?? "Id";
    }

    /// <summary>
    /// Gets the ID value from an entity instance.
    /// </summary>
    private TId GetIdValue(T entity)
    {
        var prop = typeof(T).GetProperty(_idColumn);
        return (TId)prop!.GetValue(entity)!;
    }

    #endregion
}
```

---

### Task 1.6: Implement Entity-Specific Repositories

**File:** `src/Lexichord.Abstractions/Contracts/IUserRepository.cs`

```csharp
using Lexichord.Abstractions.Entities;

namespace Lexichord.Abstractions.Contracts;

/// <summary>
/// Repository for User entity operations.
/// </summary>
/// <remarks>
/// LOGIC: Extends IGenericRepository with User-specific query methods.
/// These methods provide optimized access patterns for common operations.
/// </remarks>
public interface IUserRepository : IGenericRepository<User, Guid>
{
    /// <summary>
    /// Gets a user by email address.
    /// </summary>
    /// <param name="email">The email address (case-insensitive).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The user, or null if not found.</returns>
    Task<User?> GetByEmailAsync(string email, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all active users.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>All active users.</returns>
    Task<IEnumerable<User>> GetActiveUsersAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Checks if an email address is already registered.
    /// </summary>
    /// <param name="email">The email address (case-insensitive).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the email exists.</returns>
    Task<bool> EmailExistsAsync(string email, CancellationToken cancellationToken = default);

    /// <summary>
    /// Searches users by display name or email.
    /// </summary>
    /// <param name="searchTerm">The search term.</param>
    /// <param name="maxResults">Maximum results to return.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Matching users.</returns>
    Task<IEnumerable<User>> SearchAsync(
        string searchTerm,
        int maxResults = 50,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Deactivates a user (soft delete).
    /// </summary>
    /// <param name="userId">The user ID.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the user was deactivated.</returns>
    Task<bool> DeactivateAsync(Guid userId, CancellationToken cancellationToken = default);

    /// <summary>
    /// Reactivates a user.
    /// </summary>
    /// <param name="userId">The user ID.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if the user was reactivated.</returns>
    Task<bool> ReactivateAsync(Guid userId, CancellationToken cancellationToken = default);
}
```

**File:** `src/Lexichord.Infrastructure/Data/UserRepository.cs`

```csharp
using Dapper;
using Microsoft.Extensions.Logging;
using Lexichord.Abstractions.Contracts;
using Lexichord.Abstractions.Entities;

namespace Lexichord.Infrastructure.Data;

/// <summary>
/// User repository implementation.
/// </summary>
public class UserRepository : GenericRepository<User, Guid>, IUserRepository
{
    private readonly IDbConnectionFactory _connectionFactory;
    private readonly ILogger<UserRepository> _logger;

    public UserRepository(
        IDbConnectionFactory connectionFactory,
        ILogger<UserRepository> logger)
        : base(connectionFactory, logger)
    {
        _connectionFactory = connectionFactory;
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<User?> GetByEmailAsync(string email, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        // LOGIC: Use LOWER() for case-insensitive comparison
        var sql = @"
            SELECT * FROM ""Users""
            WHERE LOWER(""Email"") = LOWER(@Email)";

        var command = new CommandDefinition(sql, new { Email = email }, cancellationToken: cancellationToken);
        var user = await connection.QuerySingleOrDefaultAsync<User>(command);

        _logger.LogDebug("GetByEmail {Email}: {Result}", email, user is not null ? "Found" : "NotFound");

        return user;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<User>> GetActiveUsersAsync(CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"
            SELECT * FROM ""Users""
            WHERE ""IsActive"" = TRUE
            ORDER BY ""DisplayName""";

        var command = new CommandDefinition(sql, cancellationToken: cancellationToken);
        var users = await connection.QueryAsync<User>(command);

        _logger.LogDebug("GetActiveUsers: {Count} users", users.Count());

        return users;
    }

    /// <inheritdoc/>
    public async Task<bool> EmailExistsAsync(string email, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"
            SELECT EXISTS(
                SELECT 1 FROM ""Users""
                WHERE LOWER(""Email"") = LOWER(@Email)
            )";

        var command = new CommandDefinition(sql, new { Email = email }, cancellationToken: cancellationToken);
        var exists = await connection.ExecuteScalarAsync<bool>(command);

        _logger.LogDebug("EmailExists {Email}: {Exists}", email, exists);

        return exists;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<User>> SearchAsync(
        string searchTerm,
        int maxResults = 50,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        // LOGIC: Use pg_trgm similarity or ILIKE for search
        var sql = @"
            SELECT * FROM ""Users""
            WHERE ""DisplayName"" ILIKE @Pattern
               OR ""Email"" ILIKE @Pattern
            ORDER BY ""DisplayName""
            LIMIT @MaxResults";

        var pattern = $"%{searchTerm}%";
        var command = new CommandDefinition(
            sql,
            new { Pattern = pattern, MaxResults = maxResults },
            cancellationToken: cancellationToken);

        var users = await connection.QueryAsync<User>(command);

        _logger.LogDebug("Search '{Term}': {Count} results", searchTerm, users.Count());

        return users;
    }

    /// <inheritdoc/>
    public async Task<bool> DeactivateAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"
            UPDATE ""Users""
            SET ""IsActive"" = FALSE
            WHERE ""Id"" = @UserId AND ""IsActive"" = TRUE";

        var command = new CommandDefinition(sql, new { UserId = userId }, cancellationToken: cancellationToken);
        var affected = await connection.ExecuteAsync(command);

        var deactivated = affected > 0;
        _logger.LogInformation("Deactivate User {UserId}: {Result}", userId, deactivated ? "Success" : "NotFound/AlreadyInactive");

        return deactivated;
    }

    /// <inheritdoc/>
    public async Task<bool> ReactivateAsync(Guid userId, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"
            UPDATE ""Users""
            SET ""IsActive"" = TRUE
            WHERE ""Id"" = @UserId AND ""IsActive"" = FALSE";

        var command = new CommandDefinition(sql, new { UserId = userId }, cancellationToken: cancellationToken);
        var affected = await connection.ExecuteAsync(command);

        var reactivated = affected > 0;
        _logger.LogInformation("Reactivate User {UserId}: {Result}", userId, reactivated ? "Success" : "NotFound/AlreadyActive");

        return reactivated;
    }
}
```

**File:** `src/Lexichord.Abstractions/Contracts/ISystemSettingsRepository.cs`

```csharp
using Lexichord.Abstractions.Entities;

namespace Lexichord.Abstractions.Contracts;

/// <summary>
/// Repository for SystemSettings key-value operations.
/// </summary>
/// <remarks>
/// LOGIC: Provides a simplified interface for key-value settings operations.
/// Unlike IGenericRepository, this interface is optimized for key-based access.
/// </remarks>
public interface ISystemSettingsRepository
{
    /// <summary>
    /// Gets a setting by key.
    /// </summary>
    /// <param name="key">The setting key.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The setting, or null if not found.</returns>
    Task<SystemSetting?> GetByKeyAsync(string key, CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a setting value by key, returning a default if not found.
    /// </summary>
    /// <param name="key">The setting key.</param>
    /// <param name="defaultValue">The default value if setting not found.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The setting value, or the default.</returns>
    Task<string> GetValueAsync(
        string key,
        string defaultValue = "",
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets a typed setting value by key.
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="key">The setting key.</param>
    /// <param name="defaultValue">The default value if setting not found or conversion fails.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>The typed setting value, or the default.</returns>
    /// <example>
    /// <code>
    /// var maxRetries = await settings.GetValueAsync&lt;int&gt;("app:max_retries", 3);
    /// var isEnabled = await settings.GetValueAsync&lt;bool&gt;("feature:dark_mode", false);
    /// </code>
    /// </example>
    Task<T> GetValueAsync<T>(
        string key,
        T defaultValue,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Sets a setting value (upsert).
    /// </summary>
    /// <param name="key">The setting key.</param>
    /// <param name="value">The setting value.</param>
    /// <param name="description">Optional description (only set on insert, not update).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task SetValueAsync(
        string key,
        string value,
        string? description = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Sets a typed setting value (upsert).
    /// </summary>
    /// <typeparam name="T">The value type.</typeparam>
    /// <param name="key">The setting key.</param>
    /// <param name="value">The setting value.</param>
    /// <param name="description">Optional description.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    Task SetValueAsync<T>(
        string key,
        T value,
        string? description = null,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all settings.
    /// </summary>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>All settings.</returns>
    Task<IEnumerable<SystemSetting>> GetAllAsync(CancellationToken cancellationToken = default);

    /// <summary>
    /// Gets all settings matching a key prefix.
    /// </summary>
    /// <param name="prefix">The key prefix (e.g., "feature:" returns all feature flags).</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>Matching settings.</returns>
    Task<IEnumerable<SystemSetting>> GetByPrefixAsync(
        string prefix,
        CancellationToken cancellationToken = default);

    /// <summary>
    /// Deletes a setting by key.
    /// </summary>
    /// <param name="key">The setting key.</param>
    /// <param name="cancellationToken">Cancellation token.</param>
    /// <returns>True if deleted, false if not found.</returns>
    Task<bool> DeleteAsync(string key, CancellationToken cancellationToken = default);
}
```

**File:** `src/Lexichord.Infrastructure/Data/SystemSettingsRepository.cs`

```csharp
using System.Text.Json;
using Dapper;
using Microsoft.Extensions.Logging;
using Lexichord.Abstractions.Contracts;
using Lexichord.Abstractions.Entities;

namespace Lexichord.Infrastructure.Data;

/// <summary>
/// SystemSettings repository implementation.
/// </summary>
public class SystemSettingsRepository : ISystemSettingsRepository
{
    private readonly IDbConnectionFactory _connectionFactory;
    private readonly ILogger<SystemSettingsRepository> _logger;

    public SystemSettingsRepository(
        IDbConnectionFactory connectionFactory,
        ILogger<SystemSettingsRepository> logger)
    {
        _connectionFactory = connectionFactory;
        _logger = logger;
    }

    /// <inheritdoc/>
    public async Task<SystemSetting?> GetByKeyAsync(string key, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"SELECT * FROM ""SystemSettings"" WHERE ""Key"" = @Key";
        var command = new CommandDefinition(sql, new { Key = key }, cancellationToken: cancellationToken);
        var setting = await connection.QuerySingleOrDefaultAsync<SystemSetting>(command);

        _logger.LogDebug("GetByKey '{Key}': {Result}", key, setting is not null ? "Found" : "NotFound");

        return setting;
    }

    /// <inheritdoc/>
    public async Task<string> GetValueAsync(
        string key,
        string defaultValue = "",
        CancellationToken cancellationToken = default)
    {
        var setting = await GetByKeyAsync(key, cancellationToken);
        return setting?.Value ?? defaultValue;
    }

    /// <inheritdoc/>
    public async Task<T> GetValueAsync<T>(
        string key,
        T defaultValue,
        CancellationToken cancellationToken = default)
    {
        var setting = await GetByKeyAsync(key, cancellationToken);
        if (setting is null)
            return defaultValue;

        try
        {
            // Handle common types directly
            var targetType = typeof(T);

            if (targetType == typeof(string))
                return (T)(object)setting.Value;

            if (targetType == typeof(bool))
                return (T)(object)bool.Parse(setting.Value);

            if (targetType == typeof(int))
                return (T)(object)int.Parse(setting.Value);

            if (targetType == typeof(long))
                return (T)(object)long.Parse(setting.Value);

            if (targetType == typeof(double))
                return (T)(object)double.Parse(setting.Value);

            if (targetType == typeof(decimal))
                return (T)(object)decimal.Parse(setting.Value);

            if (targetType == typeof(DateTime))
                return (T)(object)DateTime.Parse(setting.Value);

            if (targetType == typeof(DateTimeOffset))
                return (T)(object)DateTimeOffset.Parse(setting.Value);

            if (targetType == typeof(Guid))
                return (T)(object)Guid.Parse(setting.Value);

            // For complex types, use JSON deserialization
            return JsonSerializer.Deserialize<T>(setting.Value) ?? defaultValue;
        }
        catch (Exception ex)
        {
            _logger.LogWarning(ex, "Failed to convert setting '{Key}' to {Type}, using default", key, typeof(T).Name);
            return defaultValue;
        }
    }

    /// <inheritdoc/>
    public async Task SetValueAsync(
        string key,
        string value,
        string? description = null,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        // LOGIC: PostgreSQL UPSERT using ON CONFLICT
        var sql = @"
            INSERT INTO ""SystemSettings"" (""Key"", ""Value"", ""Description"", ""UpdatedAt"")
            VALUES (@Key, @Value, @Description, NOW())
            ON CONFLICT (""Key"")
            DO UPDATE SET ""Value"" = @Value, ""UpdatedAt"" = NOW()";

        var command = new CommandDefinition(
            sql,
            new { Key = key, Value = value, Description = description },
            cancellationToken: cancellationToken);

        await connection.ExecuteAsync(command);

        _logger.LogDebug("SetValue '{Key}' = '{Value}'", key, TruncateValue(value));
    }

    /// <inheritdoc/>
    public async Task SetValueAsync<T>(
        string key,
        T value,
        string? description = null,
        CancellationToken cancellationToken = default)
    {
        var stringValue = value switch
        {
            string s => s,
            bool b => b.ToString().ToLowerInvariant(),
            IFormattable f => f.ToString(null, System.Globalization.CultureInfo.InvariantCulture),
            _ => JsonSerializer.Serialize(value)
        };

        await SetValueAsync(key, stringValue!, description, cancellationToken);
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<SystemSetting>> GetAllAsync(CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"SELECT * FROM ""SystemSettings"" ORDER BY ""Key""";
        var command = new CommandDefinition(sql, cancellationToken: cancellationToken);
        var settings = await connection.QueryAsync<SystemSetting>(command);

        _logger.LogDebug("GetAll: {Count} settings", settings.Count());

        return settings;
    }

    /// <inheritdoc/>
    public async Task<IEnumerable<SystemSetting>> GetByPrefixAsync(
        string prefix,
        CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"
            SELECT * FROM ""SystemSettings""
            WHERE ""Key"" LIKE @Pattern
            ORDER BY ""Key""";

        var pattern = prefix + "%";
        var command = new CommandDefinition(sql, new { Pattern = pattern }, cancellationToken: cancellationToken);
        var settings = await connection.QueryAsync<SystemSetting>(command);

        _logger.LogDebug("GetByPrefix '{Prefix}': {Count} settings", prefix, settings.Count());

        return settings;
    }

    /// <inheritdoc/>
    public async Task<bool> DeleteAsync(string key, CancellationToken cancellationToken = default)
    {
        await using var connection = await _connectionFactory.CreateConnectionAsync(cancellationToken);

        var sql = @"DELETE FROM ""SystemSettings"" WHERE ""Key"" = @Key";
        var command = new CommandDefinition(sql, new { Key = key }, cancellationToken: cancellationToken);
        var affected = await connection.ExecuteAsync(command);

        var deleted = affected > 0;
        _logger.LogDebug("Delete '{Key}': {Result}", key, deleted ? "Deleted" : "NotFound");

        return deleted;
    }

    /// <summary>
    /// Truncates a value for logging (avoid logging large values).
    /// </summary>
    private static string TruncateValue(string value, int maxLength = 50)
    {
        return value.Length <= maxLength
            ? value
            : value[..maxLength] + "...";
    }
}
```

---

### Task 1.7: Register Repositories in DI

**File:** `src/Lexichord.Infrastructure/InfrastructureServices.cs` (Update)

```csharp
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.DependencyInjection;
using Lexichord.Abstractions.Contracts;
using Lexichord.Infrastructure.Data;
using Lexichord.Infrastructure.Migrations;

namespace Lexichord.Infrastructure;

/// <summary>
/// Extension methods for registering Infrastructure services.
/// </summary>
public static class InfrastructureServices
{
    /// <summary>
    /// Adds all Infrastructure services to the DI container.
    /// </summary>
    public static IServiceCollection AddInfrastructureServices(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        // Database connectivity
        services.AddDatabaseServices(configuration);

        // Repositories
        services.AddRepositories();

        // Migrations
        services.AddMigrationServices();

        return services;
    }

    /// <summary>
    /// Adds database connectivity services.
    /// </summary>
    public static IServiceCollection AddDatabaseServices(
        this IServiceCollection services,
        IConfiguration configuration)
    {
        services.Configure<DatabaseOptions>(
            configuration.GetSection(DatabaseOptions.SectionName));

        services.AddSingleton<IDbConnectionFactory, NpgsqlConnectionFactory>();

        return services;
    }

    /// <summary>
    /// Adds repository services.
    /// </summary>
    public static IServiceCollection AddRepositories(this IServiceCollection services)
    {
        // LOGIC: Repositories are registered as Scoped because they use connections
        // from the pool. Each scope (e.g., request) gets its own instance.
        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<ISystemSettingsRepository, SystemSettingsRepository>();

        // Generic repository can be registered for any entity type
        services.AddScoped(typeof(IGenericRepository<,>), typeof(GenericRepository<,>));

        // Unit of work for transactions
        services.AddScoped<IUnitOfWork, UnitOfWork>();

        return services;
    }
}
```

---

## 4. Decision Tree: Repository Method Selection

```text
START: "What data operation do I need?"
|
+-- Simple CRUD by ID?
|   +-- Get by ID -> GetByIdAsync(id)
|   +-- Insert new -> InsertAsync(entity)
|   +-- Update existing -> UpdateAsync(entity)
|   +-- Delete by ID -> DeleteAsync(id)
|
+-- Get multiple entities?
|   +-- Get all (small tables only) -> GetAllAsync()
|   +-- Get with pagination -> GetPagedAsync(page, size)
|   +-- Custom filter -> QueryAsync<T>("SELECT ... WHERE ...")
|
+-- Check existence?
|   +-- By ID -> ExistsAsync(id)
|   +-- By custom criteria -> QuerySingleOrDefaultAsync<bool>("SELECT EXISTS(...)")
|
+-- Count entities?
|   +-- Total count -> CountAsync()
|   +-- Custom count -> ExecuteScalarAsync<long>("SELECT COUNT(...) WHERE ...")
|
+-- Custom query?
|   +-- Returns entities -> QueryAsync<T>(sql, params)
|   +-- Returns single -> QuerySingleOrDefaultAsync<T>(sql, params)
|   +-- Returns scalar -> ExecuteScalarAsync<T>(sql, params)
|   +-- No return (INSERT/UPDATE/DELETE) -> ExecuteAsync(sql, params)
|
+-- Transaction needed?
    +-- Create IUnitOfWork scope
    +-- Begin transaction
    +-- Execute operations
    +-- Commit or Rollback
```

---

## 5. Unit Testing Requirements

### 5.1 Test: Generic Repository CRUD

```csharp
[TestFixture]
[Category("Integration")]
[Explicit("Requires running PostgreSQL")]
public class GenericRepositoryTests
{
    private IDbConnectionFactory _connectionFactory = null!;
    private IUserRepository _userRepo = null!;

    [SetUp]
    public async Task SetUp()
    {
        var options = Options.Create(new DatabaseOptions
        {
            ConnectionString = GetTestConnectionString()
        });

        var connLogger = new Mock<ILogger<NpgsqlConnectionFactory>>();
        _connectionFactory = new NpgsqlConnectionFactory(options, connLogger.Object);

        var repoLogger = new Mock<ILogger<UserRepository>>();
        _userRepo = new UserRepository(_connectionFactory, repoLogger.Object);

        // Clean up test data
        await _userRepo.ExecuteAsync("DELETE FROM \"Users\" WHERE \"Email\" LIKE '%@test.local'");
    }

    [TearDown]
    public async Task TearDown()
    {
        // Clean up
        await _userRepo.ExecuteAsync("DELETE FROM \"Users\" WHERE \"Email\" LIKE '%@test.local'");
        (_connectionFactory as IDisposable)?.Dispose();
    }

    [Test]
    public async Task InsertAsync_CreatesUser_ReturnsWithId()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"test-{Guid.NewGuid()}@test.local",
            DisplayName = "Test User"
        };

        // Act
        var inserted = await _userRepo.InsertAsync(user);

        // Assert
        Assert.That(inserted.Id, Is.EqualTo(user.Id));
        Assert.That(inserted.Email, Is.EqualTo(user.Email));
        Assert.That(inserted.CreatedAt, Is.Not.EqualTo(default(DateTimeOffset)));
    }

    [Test]
    public async Task GetByIdAsync_ExistingUser_ReturnsUser()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"test-{Guid.NewGuid()}@test.local",
            DisplayName = "Test User"
        };
        await _userRepo.InsertAsync(user);

        // Act
        var retrieved = await _userRepo.GetByIdAsync(user.Id);

        // Assert
        Assert.That(retrieved, Is.Not.Null);
        Assert.That(retrieved!.Email, Is.EqualTo(user.Email));
    }

    [Test]
    public async Task GetByIdAsync_NonExistingUser_ReturnsNull()
    {
        // Act
        var result = await _userRepo.GetByIdAsync(Guid.NewGuid());

        // Assert
        Assert.That(result, Is.Null);
    }

    [Test]
    public async Task UpdateAsync_ExistingUser_ReturnsTrue()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"test-{Guid.NewGuid()}@test.local",
            DisplayName = "Original Name"
        };
        var inserted = await _userRepo.InsertAsync(user);

        var updated = inserted with { DisplayName = "Updated Name" };

        // Act
        var result = await _userRepo.UpdateAsync(updated);

        // Assert
        Assert.That(result, Is.True);

        var retrieved = await _userRepo.GetByIdAsync(user.Id);
        Assert.That(retrieved!.DisplayName, Is.EqualTo("Updated Name"));
    }

    [Test]
    public async Task DeleteAsync_ExistingUser_ReturnsTrue()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"test-{Guid.NewGuid()}@test.local",
            DisplayName = "To Delete"
        };
        await _userRepo.InsertAsync(user);

        // Act
        var result = await _userRepo.DeleteAsync(user.Id);

        // Assert
        Assert.That(result, Is.True);
        Assert.That(await _userRepo.ExistsAsync(user.Id), Is.False);
    }

    [Test]
    public async Task GetPagedAsync_ReturnsCorrectPage()
    {
        // Arrange - Insert 15 users
        for (var i = 0; i < 15; i++)
        {
            await _userRepo.InsertAsync(new User
            {
                Id = Guid.NewGuid(),
                Email = $"paged-{i:D2}@test.local",
                DisplayName = $"User {i}"
            });
        }

        // Act - Get page 2 with size 5
        var result = await _userRepo.GetPagedAsync(2, 5);

        // Assert
        Assert.Multiple(() =>
        {
            Assert.That(result.Items.Count(), Is.EqualTo(5));
            Assert.That(result.PageNumber, Is.EqualTo(2));
            Assert.That(result.PageSize, Is.EqualTo(5));
            Assert.That(result.TotalCount, Is.GreaterThanOrEqualTo(15));
            Assert.That(result.TotalPages, Is.GreaterThanOrEqualTo(3));
            Assert.That(result.HasPreviousPage, Is.True);
            Assert.That(result.HasNextPage, Is.True);
        });
    }

    private static string GetTestConnectionString()
    {
        return Environment.GetEnvironmentVariable("LEXICHORD_TEST_DB")
            ?? "Host=localhost;Port=5432;Database=lexichord_test;Username=lexichord;Password=lexichord_dev";
    }
}
```

### 5.2 Test: User Repository Custom Methods

```csharp
[TestFixture]
[Category("Integration")]
[Explicit("Requires running PostgreSQL")]
public class UserRepositoryTests
{
    private IUserRepository _sut = null!;

    [SetUp]
    public async Task SetUp()
    {
        // Setup similar to GenericRepositoryTests
    }

    [Test]
    public async Task GetByEmailAsync_CaseInsensitive()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = "Test.User@test.local",
            DisplayName = "Test User"
        };
        await _sut.InsertAsync(user);

        // Act
        var result = await _sut.GetByEmailAsync("TEST.USER@TEST.LOCAL");

        // Assert
        Assert.That(result, Is.Not.Null);
        Assert.That(result!.Id, Is.EqualTo(user.Id));
    }

    [Test]
    public async Task EmailExistsAsync_ReturnsTrue_WhenExists()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"exists-{Guid.NewGuid()}@test.local",
            DisplayName = "Test User"
        };
        await _sut.InsertAsync(user);

        // Act
        var exists = await _sut.EmailExistsAsync(user.Email);

        // Assert
        Assert.That(exists, Is.True);
    }

    [Test]
    public async Task GetActiveUsersAsync_ExcludesInactive()
    {
        // Arrange
        var activeUser = new User
        {
            Id = Guid.NewGuid(),
            Email = $"active-{Guid.NewGuid()}@test.local",
            DisplayName = "Active User",
            IsActive = true
        };
        var inactiveUser = new User
        {
            Id = Guid.NewGuid(),
            Email = $"inactive-{Guid.NewGuid()}@test.local",
            DisplayName = "Inactive User",
            IsActive = false
        };

        await _sut.InsertAsync(activeUser);
        await _sut.InsertAsync(inactiveUser);

        // Act
        var activeUsers = await _sut.GetActiveUsersAsync();

        // Assert
        Assert.That(activeUsers.Any(u => u.Id == activeUser.Id), Is.True);
        Assert.That(activeUsers.Any(u => u.Id == inactiveUser.Id), Is.False);
    }

    [Test]
    public async Task DeactivateAsync_SetsIsActiveFalse()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"deactivate-{Guid.NewGuid()}@test.local",
            DisplayName = "To Deactivate",
            IsActive = true
        };
        await _sut.InsertAsync(user);

        // Act
        var result = await _sut.DeactivateAsync(user.Id);

        // Assert
        Assert.That(result, Is.True);

        var retrieved = await _sut.GetByIdAsync(user.Id);
        Assert.That(retrieved!.IsActive, Is.False);
    }

    [Test]
    public async Task SearchAsync_FindsByDisplayName()
    {
        // Arrange
        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = $"search-{Guid.NewGuid()}@test.local",
            DisplayName = "Unique SearchTerm123 Name"
        };
        await _sut.InsertAsync(user);

        // Act
        var results = await _sut.SearchAsync("SearchTerm123");

        // Assert
        Assert.That(results.Any(u => u.Id == user.Id), Is.True);
    }
}
```

### 5.3 Test: SystemSettings Repository

```csharp
[TestFixture]
[Category("Integration")]
[Explicit("Requires running PostgreSQL")]
public class SystemSettingsRepositoryTests
{
    private ISystemSettingsRepository _sut = null!;

    [SetUp]
    public async Task SetUp()
    {
        // Setup similar to previous tests
    }

    [TearDown]
    public async Task TearDown()
    {
        // Clean up test settings
        await _sut.DeleteAsync("test:setting");
        await _sut.DeleteAsync("test:typed:int");
        await _sut.DeleteAsync("test:typed:bool");
    }

    [Test]
    public async Task SetValueAsync_GetValueAsync_RoundTrips()
    {
        // Arrange
        var key = "test:setting";
        var value = "test-value-123";

        // Act
        await _sut.SetValueAsync(key, value, "Test description");
        var result = await _sut.GetValueAsync(key);

        // Assert
        Assert.That(result, Is.EqualTo(value));
    }

    [Test]
    public async Task SetValueAsync_Upserts()
    {
        // Arrange
        var key = "test:setting";

        // Act - Insert then update
        await _sut.SetValueAsync(key, "value1");
        await _sut.SetValueAsync(key, "value2");

        var result = await _sut.GetValueAsync(key);

        // Assert
        Assert.That(result, Is.EqualTo("value2"));
    }

    [Test]
    public async Task GetValueAsync_NotFound_ReturnsDefault()
    {
        // Act
        var result = await _sut.GetValueAsync("nonexistent:key", "default-value");

        // Assert
        Assert.That(result, Is.EqualTo("default-value"));
    }

    [Test]
    public async Task GetValueAsync_Typed_Int()
    {
        // Arrange
        await _sut.SetValueAsync("test:typed:int", "42");

        // Act
        var result = await _sut.GetValueAsync<int>("test:typed:int", 0);

        // Assert
        Assert.That(result, Is.EqualTo(42));
    }

    [Test]
    public async Task GetValueAsync_Typed_Bool()
    {
        // Arrange
        await _sut.SetValueAsync("test:typed:bool", "true");

        // Act
        var result = await _sut.GetValueAsync<bool>("test:typed:bool", false);

        // Assert
        Assert.That(result, Is.True);
    }

    [Test]
    public async Task GetByPrefixAsync_FiltersCorrectly()
    {
        // Arrange
        await _sut.SetValueAsync("test:prefix:a", "value-a");
        await _sut.SetValueAsync("test:prefix:b", "value-b");
        await _sut.SetValueAsync("other:prefix:c", "value-c");

        // Act
        var results = await _sut.GetByPrefixAsync("test:prefix:");

        // Assert
        Assert.That(results.Count(), Is.EqualTo(2));
        Assert.That(results.All(s => s.Key.StartsWith("test:prefix:")), Is.True);
    }
}
```

---

## 6. Observability & Logging

### 6.1 Log Events

| Level       | Context                   | Message Template                                              |
| :---------- | :------------------------ | :------------------------------------------------------------ |
| Debug       | GenericRepository         | `GetById {Table} Id={Id}: {Result}`                           |
| Debug       | GenericRepository         | `GetAll {Table}: {Count} records`                             |
| Debug       | GenericRepository         | `GetPaged {Table} Page={Page} Size={Size}: {Count} of {Total}`|
| Debug       | GenericRepository         | `Exists {Table} Id={Id}: {Exists}`                            |
| Debug       | GenericRepository         | `Count {Table}: {Count}`                                      |
| Debug       | GenericRepository         | `Insert {Table}: Success (Id={Id})`                           |
| Debug       | GenericRepository         | `InsertMany {Table}: {Count} entities`                        |
| Debug       | GenericRepository         | `Update {Table} Id={Id}: {Result}`                            |
| Debug       | GenericRepository         | `Delete {Table} Id={Id}: {Result}`                            |
| Debug       | GenericRepository         | `Query executed: {Count} results`                             |
| Debug       | GenericRepository         | `QuerySingle executed: {Found}`                               |
| Debug       | GenericRepository         | `Execute completed: {Affected} rows affected`                 |
| Debug       | UserRepository            | `GetByEmail {Email}: {Result}`                                |
| Debug       | UserRepository            | `GetActiveUsers: {Count} users`                               |
| Debug       | UserRepository            | `EmailExists {Email}: {Exists}`                               |
| Debug       | UserRepository            | `Search '{Term}': {Count} results`                            |
| Information | UserRepository            | `Deactivate User {UserId}: {Result}`                          |
| Information | UserRepository            | `Reactivate User {UserId}: {Result}`                          |
| Debug       | SystemSettingsRepository  | `GetByKey '{Key}': {Result}`                                  |
| Debug       | SystemSettingsRepository  | `SetValue '{Key}' = '{Value}'`                                |
| Debug       | SystemSettingsRepository  | `GetAll: {Count} settings`                                    |
| Debug       | SystemSettingsRepository  | `GetByPrefix '{Prefix}': {Count} settings`                    |
| Debug       | SystemSettingsRepository  | `Delete '{Key}': {Result}`                                    |
| Warning     | SystemSettingsRepository  | `Failed to convert setting '{Key}' to {Type}, using default`  |

---

## 7. Security & Safety

### 7.1 SQL Injection Prevention

> [!IMPORTANT]
> All queries MUST use parameterized queries. Never concatenate user input into SQL.

```csharp
// CORRECT: Parameterized query
await repo.QueryAsync<User>(
    "SELECT * FROM \"Users\" WHERE \"Email\" = @Email",
    new { Email = userInput });

// WRONG: SQL injection vulnerability!
await repo.QueryAsync<User>(
    $"SELECT * FROM \"Users\" WHERE \"Email\" = '{userInput}'");
```

### 7.2 Sensitive Data Handling

- Never log full user records (may contain password hashes)
- Truncate long values before logging
- Use structured logging with explicit properties

---

## 8. Definition of Done

- [ ] `Dapper` and `Dapper.Contrib` packages installed
- [ ] `EntityBase` class with audit fields defined
- [ ] `User` entity with all fields and attributes defined
- [ ] `SystemSetting` entity with all fields and attributes defined
- [ ] `IGenericRepository<T, TId>` interface with full CRUD methods
- [ ] `PagedResult<T>` record for pagination support
- [ ] `GenericRepository<T, TId>` implementation with Dapper
- [ ] `IUserRepository` interface with custom methods
- [ ] `UserRepository` implementation complete
- [ ] `ISystemSettingsRepository` interface defined
- [ ] `SystemSettingsRepository` implementation complete
- [ ] Typed settings getter/setter methods working
- [ ] All repositories registered in DI container
- [ ] Integration tests for GenericRepository passing
- [ ] Integration tests for UserRepository passing
- [ ] Integration tests for SystemSettingsRepository passing
- [ ] All log events implemented

---

## 9. Verification Commands

```bash
# 1. Start test database
./scripts/db-start.sh

# 2. Run migrations (creates tables)
dotnet run --project src/Lexichord.Host -- --migrate

# 3. Run integration tests
LEXICHORD_TEST_DB="Host=localhost;Port=5432;Database=lexichord;Username=lexichord;Password=lexichord_dev" \
  dotnet test --filter "Category=Integration&FullyQualifiedName~Repository"

# 4. Test CRUD manually with psql
docker exec -it lexichord-postgres psql -U lexichord -d lexichord

# In psql:
# Insert a user
INSERT INTO "Users" ("Id", "Email", "DisplayName")
VALUES ('11111111-1111-1111-1111-111111111111', 'manual@test.local', 'Manual Test');

# Query users
SELECT * FROM "Users";

# Check system settings
SELECT * FROM "SystemSettings";

# Exit psql
\q

# 5. Cleanup
./scripts/db-reset.sh
```

---

## 10. Usage Examples

### Basic CRUD

```csharp
public class UserService(IUserRepository userRepo)
{
    public async Task<User> CreateUserAsync(string email, string displayName)
    {
        if (await userRepo.EmailExistsAsync(email))
            throw new InvalidOperationException("Email already exists");

        var user = new User
        {
            Id = Guid.NewGuid(),
            Email = email,
            DisplayName = displayName
        };

        return await userRepo.InsertAsync(user);
    }

    public async Task<User?> GetUserByIdAsync(Guid id)
    {
        return await userRepo.GetByIdAsync(id);
    }

    public async Task<PagedResult<User>> GetUsersPagedAsync(int page, int size)
    {
        return await userRepo.GetPagedAsync(page, size);
    }
}
```

### Using Settings

```csharp
public class FeatureFlagService(ISystemSettingsRepository settings)
{
    public async Task<bool> IsFeatureEnabledAsync(string featureName)
    {
        return await settings.GetValueAsync<bool>($"feature:{featureName}", false);
    }

    public async Task SetFeatureAsync(string featureName, bool enabled)
    {
        await settings.SetValueAsync($"feature:{featureName}", enabled, $"Feature flag for {featureName}");
    }

    public async Task<Dictionary<string, bool>> GetAllFeatureFlagsAsync()
    {
        var features = await settings.GetByPrefixAsync("feature:");
        return features.ToDictionary(
            s => s.Key.Replace("feature:", ""),
            s => bool.Parse(s.Value));
    }
}
```

### Transactions with Unit of Work

```csharp
public class UserRegistrationService(
    IUserRepository userRepo,
    ISystemSettingsRepository settings,
    IUnitOfWork unitOfWork)
{
    public async Task RegisterUserAsync(string email, string displayName)
    {
        await unitOfWork.BeginTransactionAsync();

        try
        {
            // Create user
            var user = new User
            {
                Id = Guid.NewGuid(),
                Email = email,
                DisplayName = displayName
            };
            await userRepo.InsertAsync(user);

            // Update registration count
            var count = await settings.GetValueAsync<int>("stats:user_count", 0);
            await settings.SetValueAsync("stats:user_count", count + 1);

            await unitOfWork.CommitAsync();
        }
        catch
        {
            await unitOfWork.RollbackAsync();
            throw;
        }
    }
}
```
